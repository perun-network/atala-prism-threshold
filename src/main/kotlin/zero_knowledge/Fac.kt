package perun_network.ecdsa_threshold.zero_knowledge

import perun_network.ecdsa_threshold.math.*
import perun_network.ecdsa_threshold.pedersen.PedersenParameters
import java.math.BigInteger
import java.security.MessageDigest

/**
 * Public parameters for the  Small-Factor Proof (Πfac) zero-knowledge proof.
 *
 * @property n RSA Modulus of the prover.
 * @property aux Pedersen parameters for commitment schemes.
 */
data class FacPublic(
    val n: BigInteger,
    val aux: PedersenParameters
)

/**
 * Private parameters for the Range Proof w/ EL-Gamal Commitment (Enc-Elg) zero-knowledge proof.
 *
 * @property p Prime factor of Paillier's secret.
 * @property q Prime factor of Paillier's secret.
 */
data class FacPrivate(
    val p: BigInteger,
    val q: BigInteger
)

/**
 * Commitment values generated by the prover during the proof process.
 *
 * @property P Commitment to `p` using Pedersen commitments: `P = s^p * t^μ mod N̂`.
 * @property Q Commitment to `q` using Pedersen commitments: `Q = s^q * t^ν mod N̂`.
 * @property A Commitment to the randomly sampled `α`: `A = s^α * t^x mod N̂`.
 * @property B Commitment to the randomly sampled `β`: `B = s^β * t^y mod N̂`.
 * @property T Commitment based on `Q^α * t^r mod N̂`.
 */
data class FacCommitment(
    val P: BigInteger,
    val Q: BigInteger,
    val A: BigInteger,
    val B: BigInteger,
    val T: BigInteger
)

/**
 * The proof structure for Small-Factor Proof (Πfac).
 *
 * @property comm Commitments generated by the prover.
 * @property sigma Intermediate value derived during the proof process.
 * @property z1 Response for `α + ep`, where `e` is the challenge.
 * @property z2 Response for `β + eq`, where `e` is the challenge.
 * @property w1 Response for `x + eμ`, where `e` is the challenge.
 * @property w2 Response for `y + eν`, where `e` is the challenge.
 * @property v Response for `r - eνp`, where `e` is the challenge.
 */
data class FacProof(
    val comm: FacCommitment,
    val sigma: BigInteger,
    val z1: BigInteger,
    val z2: BigInteger,
    val w1: BigInteger,
    val w2: BigInteger,
    val v: BigInteger
) {
    /**
     * Verifies the validity of the proof against the public parameters and commitments.
     *
     * @param id Identifier for the proof session.
     * @param rid Random identifier for uniqueness in the challenge generation.
     * @param public The public parameters used for verification.
     * @return `true` if the proof is valid, otherwise `false`.
     */
    internal fun verify(id: Int, rid: ByteArray, public : FacPublic) : Boolean {
        val e = challenge(id, rid, public, comm)

        val n0 = public.n
        val n = public.aux.n

        if (!public.aux.verifyCommit(z1, w1, e, comm.A, comm.P)) return false
        if (!public.aux.verifyCommit(z2, w2, e, comm.B, comm.Q)) return false

        val r = public.aux.s
            .modPow(n0, n)
            .multiply(public.aux.t.modPow(sigma, n))
            .mod(n)

        val lhs = comm.Q.modPow(z1, n)
            .multiply(public.aux.t.modPow(v, n))
            .mod(n)

        val rhs = r.modPow(e, n)
            .multiply(comm.T)
            .mod(n)

        if (lhs != rhs) return false

        // Ensure z1 and z2 are within valid intervals
        return isInIntervalLEpsPlus1RootN(z1) && isInIntervalLEpsPlus1RootN(z2)
    }

    companion object {
        /**
         * Constructs a new proof for the Small-Factor Proof (Πfac).
         *
         * @param id Identifier for the proof session.
         * @param rid Random identifier for uniqueness in the challenge generation.
         * @param public The public parameters for the proof.
         * @param private The private parameters (witnesses) of the proof.
         * @return The constructed proof.
         */
        internal fun newProof(id: Int, rid: ByteArray, public: FacPublic, private: FacPrivate): FacProof {
            val n = public.aux.n

            // Random values for proof generation
            val alpha = sampleLEpsRootN()
            val beta = sampleLEpsRootN()
            val mu = sampleLN()
            val nu = sampleLN()
            val sigma = sampleLN2()
            val r = sampleLEpsN2()
            val x = sampleLEpsN()
            val y = sampleLEpsN()

            val pInt = private.p
            val qInt = private.q

            val pCommit = public.aux.calculateCommit(pInt, mu)
            val qCommit = public.aux.calculateCommit(qInt, nu)
            val aCommit = public.aux.calculateCommit(alpha, x)
            val bCommit = public.aux.calculateCommit(beta, y)

            val tCommit = qCommit.modPow(alpha, n)
                .multiply(public.aux.t.modPow(r, n))
                .mod(n)

            val comm = FacCommitment(pCommit, qCommit, aCommit, bCommit, tCommit)

            // Generate challenge
            val e = challenge(id, rid, public, comm)

            // Compute z1, z2, w1, w2, and v
            val z1 = e.multiply(pInt).add(alpha)
            val z2 = e.multiply(qInt).add(beta)
            val w1 = e.multiply(mu).add(x)
            val w2 = e.multiply(nu).add(y)

            val sigmaHat = nu.multiply(pInt).negate().add(sigma)
            val v = e.multiply(sigmaHat).add(r)

            return FacProof(comm, sigma, z1, z2, w1, w2, v)
        }
    }
}

/**
 * Generates a cryptographic challenge `e` from the input parameters and commitments.
 *
 * @param id Identifier for the proof session.
 * @param rid Random identifier for uniqueness.
 * @param publicKey The public parameters of the proof.
 * @param commitment The commitments provided by the prover.
 * @return The challenge value `e`.
 */
fun challenge(id: Int, rid: ByteArray, publicKey: FacPublic, commitment: FacCommitment): BigInteger {
    // Initialize a MessageDigest for SHA-256
    val hash = MessageDigest.getInstance("SHA-256")
    hash.update(id.toByte())
    hash.update(rid)
    hash.update(publicKey.n.toByteArray())
    hash.update(publicKey.aux.toByteArray())
    hash.update(commitment.P.toByteArray())
    hash.update(commitment.Q.toByteArray())
    hash.update(commitment.A.toByteArray())
    hash.update(commitment.B.toByteArray())
    hash.update(commitment.T.toByteArray())

    return sampleNeg(hash.digest().inputStream(), L)
}